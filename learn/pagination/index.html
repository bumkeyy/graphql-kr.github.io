<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="google-site-verification" content="wt4jHZa0ru-stSJJrlY5sSJzj9MB0ZA6BzkprNilZdM"/><title>페이지네이션 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: API를 위한 쿼리 언어"/><meta property="og:description" content="GraphQL은 API에 있는 데이터에 대한 완벽하고 이해하기 쉬운 설명을 제공하고 클라이언트에게 필요한 것을 정확하게 요청할 수 있는 기능을 제공하며 시간이 지남에 따라 API를 쉽게 진화시키고 강력한 개발자 도구를 지원합니다."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql-kr.github.io"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: API를 위한 쿼리 언어"/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css" rel="stylesheet" type="text/css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">배우기</a><a href="/code/">코드</a><a href="/community/">커뮤니티</a><a href="/blog/">블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="문서 검색"/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>페이지네이션</h1><div><blockquote><p>다양한 페이지네이션 모델은 다양한 클라이언트 기능 지원을 가능하게합니다.</p></blockquote><p>GraphQL의 일반적인 사용 사례는 객체들 간의 관계를 탐색하는 것입니다. GraphQL에서 이러한 관계를 노출할 수 있는 다양한 방법이 있으며, 클라이언트 개발자에게 다양한 기능을 제공합니다.</p><h2><a class="anchor" name="plurals"></a>Plurals <a class="hash-link" href="#plurals">#</a></h2><p>객체 간의 연결을 노출하는 가장 간단한 방법은 복수형 타입을 반환하는 필드를 사용하는 것입니다. 예를 들어, R2-D2의 친구목록을 얻고 싶다면 그냥 전부 요청할 수 있습니다.</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><h2><a class="anchor" name="slicing"></a>Slicing <a class="hash-link" href="#slicing">#</a></h2><p>그러나 클라이언트가 추가적인 행동을 원할지도 모릅니다. 클라이언트는 친구 중 몇 명을 지정하여 가져오기를 원할 수 있습니다. 또는 가장 앞에 두 명만 원할 수도 있습니다. 그래서 아래와 같이 할 수도 있습니다.</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  hero <span class="punctuation">{</span>
    name
    friends<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      name
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>하지만 맨앞 두 개를 가져온 경우, 그 목록을 이용해 다음페이지를 원할 수 있습니다. 클라이언트가 처음 두 친구를 가져온 후, 다음 요청으로 그 다음 두 친구를 요청할 수도 있습니다. 어떻게 이를 가능하게 할 수 있을까요?</p><h2><a class="anchor" name="pagination-and-edges"></a>Pagination and Edges <a class="hash-link" href="#pagination-and-edges">#</a></h2><p>페이지네이션을 할 수 있는 방법은 여러 가지가 있습니다.</p><ul><li><code>friends(first:2 offset:2)</code> 로 리스트에서 다음 두 개를 요청할 수 있습니다.</li><li><code>friends(first:2 after:$friendId)</code> 로 우리가 가져온 마지막 친구를 이용하여 다음 두 개를 요청할 수 있습니다.</li><li><code>friends(first:2 after:$friendCursor)</code> 로 마지막 항목으로부터 커서를 가져와 페이지네이션에 사용할 수 있습니다.</li></ul><p>일반적으로 <strong>커서 기반 페이지네이션</strong>이 이 중 가장 강력하다는 것을 알 수 있습니다. 특히 커서가 확실한 경우, 커서를 offset 또는 ID로 지정한 커서 기반의 페이지네이션을 구현할 수 있으며, 커서를 사용하면 향후 페이지네이션 모델이 변경될 경우에 추가적인 유연성이 제공됩니다. 커서가 확실하고 형태를 신뢰할 수 없다는 것을 상기시켜주기 위해, base64 인코딩하는 것이 좋습니다.</p><p>이는 또다시 문제가 있습니다. 객체에서 어떻게 커서를 가져 올까요? 커서가 <code>User</code> 타입에 존재하는 것은 원치 않습니다. 이는 연결(<code>connection</code>)을 위한 속성이지 객체의 속성은 아니기 때문입니다. 그래서 간접 지정을 위해 새로운 레이어을 도입할 수 있습니다. <code>friends</code> 필드는 리스트의 맨 끝(<code>edge</code>)을 주어야하고, 그 엣지는 커서와 하위 노드를 가집니다.</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  hero <span class="punctuation">{</span>
    name
    friends<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      edges <span class="punctuation">{</span>
        node <span class="punctuation">{</span>
          name
        <span class="punctuation">}</span>
        cursor
      <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>엣지는 객체가 아닌 엣지에 자체에 특정한 정보가 있는 경우 유용합니다. 예를 들어, API에서  <code>friendship time</code>을 가져오고 싶다면, 엣지에 위치시키는 것이 자연스럽습니다.</p><h2><a class="anchor" name="end-of-list-counts-and-connections"></a>End-of-list, counts, and Connections <a class="hash-link" href="#end-of-list-counts-and-connections">#</a></h2><p>이제 커서를 사용하여 <code>connection</code>을 페이지네이션할 수 있지만, <code>connection</code>이 언제 끝났는지 어떻게 알 수 있을까요? 빈 배열을 받을 때까지 계속 쿼리해야할겁니다. 하지만 추가적인 요청 없이 <code>connection</code>이 끝났음을 알고싶을 것입니다. 마찬가지로, <code>connection</code> 자체에 대한 추가 정보를 알고 싶다면 어떻게해야할까요? 예를 들면, R2-D2는 친구가 총 몇 명인지 알고싶을때?</p><p>이 두 문제를 해결하기 위해 <code>friends</code> 필드는 <code>connection</code> 객체를 반환할 수 있습니다. <code>connection</code> 객체에는 엣지에 대한 필드뿐만 아니라 다른 정보(예: 총 갯수, 다음 페이지의 존재 여부에 대한 정보)도 있습니다. 그래서 최종 쿼리는 다음과 같을 것입니다.</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  hero <span class="punctuation">{</span>
    name
    friends<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      totalCount
      edges <span class="punctuation">{</span>
        node <span class="punctuation">{</span>
          name
        <span class="punctuation">}</span>
        cursor
      <span class="punctuation">}</span>
      pageInfo <span class="punctuation">{</span>
        endCursor
        hasNextPage
      <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>이 <code>PageInfo</code> 객체에 <code>endCursor</code> 와 <code>startCursor</code> 를 포함할 수도 있습니다. 이 방법으로, 엣지에 있는 추가적인 정보가 필요없다면, <code>pageInfo</code> 에서 페이지네이션에 필요한 커서를 얻었으므로, 더이상 엣지를 쿼리할 필요가 없습니다. 이로 인해 <code>connection</code>에 대한 유용성이 향상될 수 있습니다. 단순히 <code>edges</code> 리스트를 노출하는 대신, 간접레이어을 피하기 위해 노드의 전용 리스트를 노출할 수 있습니다.</p><h2><a class="anchor" name="complete-connection-model"></a>Complete Connection Model <a class="hash-link" href="#complete-connection-model">#</a></h2><p>이는 분명히, 그저 복수 타입을 갖는 기존 디자인보다 더 복잡합니다. 그러나 이 디자인을 채택함으로써 클라이언트를 위한 다양한 기능을 사용할 수 있게 됩니다.</p><ul><li>리스트를 페이지네이션하는 기능.</li><li><code>totalCount</code> 또는 <code>pageInfo</code> 와 같은 연결 자체에 대한 정보를 요청하는 기능.</li><li><code>cursor</code> 또는 <code>friendshipTime</code> 과 같은 엣지 자체에 대한 정보를 요청하는 기능.</li><li>사용자가 확실한 커서를 사용하는 동안, 백엔드가 페이지네이션을 수행하는 방식을 변경하는 기능.</li></ul><p>이를 실제로 확인하기 위해 예제 스키마에는 <code>friendsConnection</code> 이라는 필드가 추가되어있어, 이러한 개념을 모두 보여줍니다. 예제 쿼리에서 확인할 수 있습니다. 아래 <code>friendsConnection</code>에 <code>after</code> 매개 변수를 제거하여 페이지네이션이 어떻게 영향을 받는지 확인하세요. 또한, <code>connection</code> 에 있는 <code>friends</code>인 <code>edges</code> 필드를 바꾸어 보세요. 그러면 클라이언트에 적합하게, 간접적인 추가 엣지 레이어가 없이 친구 리스트에 직접 접근할 수 있습니다.</p><div id="r102"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div></div><a class="read-next" href="/learn/caching"><span class="read-next-continue">계속 읽기 →</span><span class="read-next-title">캐싱</span></a></div><div class="nav-docs"><div><h3>배우기</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">쿼리 &amp; 뮤테이션</a><ul><li><a href="/learn/queries/#">필드</a></li><li><a href="/learn/queries/#">인자</a></li><li><a href="/learn/queries/#">별칭</a></li><li><a href="/learn/queries/#">프래그먼트</a></li><li><a href="/learn/queries/#">작업 이름</a></li><li><a href="/learn/queries/#">변수</a></li><li><a href="/learn/queries/#">지시어</a></li><li><a href="/learn/queries/#">뮤테이션</a></li><li><a href="/learn/queries/#">인라인 프래그먼트</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">스키마 &amp; 타입</a><ul><li><a href="/learn/schema/#">타입 시스템</a></li><li><a href="/learn/schema/#">타입 언어</a></li><li><a href="/learn/schema/#">객체 타입과 필드</a></li><li><a href="/learn/schema/#">인자</a></li><li><a href="/learn/schema/#">쿼리 타입 &amp; 뮤테이션 타입</a></li><li><a href="/learn/schema/#">스칼라 타입</a></li><li><a href="/learn/schema/#">열거형 타입</a></li><li><a href="/learn/schema/#non-null">리스트와 Non-Null</a></li><li><a href="/learn/schema/#">인터페이스</a></li><li><a href="/learn/schema/#">유니온 타입</a></li><li><a href="/learn/schema/#">입력 타입</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">검증</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">실행</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">스키마 확인</a></li></ul></div><div><h3>모범 사례</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">그래프로 생각하기</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">HTTP를 통한 서빙</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">인증</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">페이지네이션</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">캐싱</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">배우기</a></h5><a href="/learn/">소개</a><a href="/learn/queries/">쿼리 언어</a><a href="/learn/schema/">타입 시스템</a><a href="/learn/execution/">실행</a><a href="/learn/best-practices/">모범 사례</a></div><div><h5><a href="/code">코드</a></h5><a href="/code/#server-libraries">서버</a><a href="/code/#graphql-clients">클라이언트</a><a href="/code/#tools">도구</a></div><div><h5><a href="/community">커뮤니티</a></h5><a href="/community/upcoming-events/">이벤트</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">스택 오버플로우</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">페이스북 그룹</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">트위터</a></div><div><h5>기타</h5><a href="/blog">GraphQL 팀 블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">깃허브</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/learn/BestPractice-Pagination.md" target="_blank" rel="noopener noreferrer">이 페이지 수정 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-99001722-7', 'auto');
ga('send', 'pageview');
(function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1273792,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
      })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.84da96035dd0755c5391.js"></script></body></html>