<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="google-site-verification" content="wt4jHZa0ru-stSJJrlY5sSJzj9MB0ZA6BzkprNilZdM"/><title>검증 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: API를 위한 쿼리 언어"/><meta property="og:description" content="GraphQL은 API에 있는 데이터에 대한 완벽하고 이해하기 쉬운 설명을 제공하고 클라이언트에게 필요한 것을 정확하게 요청할 수 있는 기능을 제공하며 시간이 지남에 따라 API를 쉽게 진화시키고 강력한 개발자 도구를 지원합니다."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql-kr.github.io"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: API를 위한 쿼리 언어"/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css" rel="stylesheet" type="text/css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">배우기</a><a href="/code/">코드</a><a href="/community/">커뮤니티</a><a href="/blog/">블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="문서 검색"/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>검증</h1><div><p>타입 시스템을 사용하면 GraphQL 쿼리가 유효한지 여부를 미리 알 수 있습니다. 이를 통해 런타임 검사에 의존하지 않고도 유효하지 않은 쿼리가 생성되었을 때 서버와 클라이언트가 효과적으로 개발자에게 알릴 수 있습니다.</p><p>Star Wars <a href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsValidation-test.js" target="_blank" rel="nofollow noopener noreferrer">starWarsValidation-test.js</a> 예제 파일에는 여러가지 유효하지 않은 쿼리가 구현되어 있으며, 참조 구현의 검사기를 실행할 수있는 테스트 파일입니다.</p><p>먼저 복잡한 중첩 쿼리를 작성해 보겠습니다. 이전 섹션의 예제와 비슷하지만, 이는 중복된 필드를 프래그먼트로 묶은 쿼리입니다.</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>이 쿼리는 유효합니다. 잘못된 쿼리 몇 가지를 살펴보겠습니다.</p><p>아래의 경우 무한한 결과를 초래할 수 있으므로 프래그먼트가 자기자신을 참조하거나 싸이클을 만들 수 없습니다! 아래는 명시적으로 세단계 중첩은 없지만 위와 동일한 쿼리입니다.</p><div id="r102"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>필드를 쿼리 할 때, 주어진 타입에 존재하는 필드를 쿼리해야합니다. <code>hero</code> 는 <code>Character</code> 를 반환합니다. 그렇기 때문에 <code>Character</code> 에 존재하는 필드를 쿼리해야합니다. 아래 타입은 <code>favoriteSpaceship</code> 필드를 가지고 있지 않으므로 이 쿼리는 유효하지 않습니다.</p><div id="r103"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>필드를 쿼리 할 때마다 스칼라나 열거형이 아닌 타입을 반환한다면 필드에서 어떤 데이터를 얻고자 하는지를 명시해야합니다. <code>Hero</code> 는 <code>Character</code> 를 반환하기 때문에, <code>name</code> 과 <code>appearIn</code> 과 같은 필드를 요청했었습니다. 하지만 이를 생략하면 쿼리가 유효하지 않습니다.</p><div id="r104"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>마찬가지로 필드가 스칼라인 경우에는 추가적인 필드를 요청하는 것은 의미가 없기 때문에 쿼리가 유효하지 않게됩니다.</p><div id="r105"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>위에서, 쿼리는 해당 타입의 필드만 쿼리 할 수 ​​있다는 점을 배웠습니다. <code>Character</code> 를 반환하는 <code>hero</code> 를 쿼리 할 때 <code>Character</code> 에 있는 필드만 쿼리 할 수 ​​있습니다. 만약 <code>R2-D2</code> 의 <code>primaryFunction</code> 을 쿼리하고자 한다면, 어떤일이 일어날까요?</p><div id="r106"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p><code>primaryFunction</code> 이 <code>Character</code> 의 필드가 아니기 때문에 이 쿼리는 유효하지 않습니다. <code>Character</code> 가 <code>Droid</code> 인 경우에만 <code>primaryFunction</code> 을 가져오고 그 외엔 그 필드를 무시하는 방법이 있어야합니다. 이전에 소개한 프래그먼트을 사용하여 이를 수행할 수 있습니다. <code>Droid</code> 에 정의된 프래그먼트를 선언하여, 정의된 곳에서만 <code>primaryFunction</code> 을 쿼리합니다.</p><div id="r107"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>이 쿼리는 유효하지만, 조금 과하다고 생각할 수 있습니다. 이름이 있는(named) 프래그먼트는 재사용할 때 비로소 가치가 있지만, 여기서는 단 한 번만 사용했기 때문입니다. 이경우에는 이름이 있는 프래그먼트를 사용하는 대신 인라인 프래그먼트을 사용할 수 있습니다. 이는 ​​별도의 프래그먼트를 분리하지 않고 쿼리하는 타입을 표현할 수 있도록 도와줍니다.</p><div id="r108"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>이것은 검증 시스템의 극히 일부입니다. GraphQL 쿼리는 의미있음을 보장하기 위한 다양한 유효성 검사 규칙이 있습니다. 명세의 &quot;검증(Validation)&quot; 섹션에서 이 주제에 대하여 좀 더 상세히 설명하며, GraphQL.js의 <a href="https://github.com/graphql/graphql-js/blob/master/src/validation" target="_blank" rel="nofollow noopener noreferrer">검증</a> 디렉토리에는 사양을 준수하는 GraphQL 검사 코드가 있습니다.</p></div><a class="read-next" href="/learn/execution"><span class="read-next-continue">계속 읽기 →</span><span class="read-next-title">실행</span></a></div><div class="nav-docs"><div><h3>배우기</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">쿼리 &amp; 뮤테이션</a><ul><li><a href="/learn/queries/#">필드</a></li><li><a href="/learn/queries/#">인자</a></li><li><a href="/learn/queries/#">별칭</a></li><li><a href="/learn/queries/#">프래그먼트</a></li><li><a href="/learn/queries/#">작업 이름</a></li><li><a href="/learn/queries/#">변수</a></li><li><a href="/learn/queries/#">지시어</a></li><li><a href="/learn/queries/#">뮤테이션</a></li><li><a href="/learn/queries/#">인라인 프래그먼트</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">스키마 &amp; 타입</a><ul><li><a href="/learn/schema/#">타입 시스템</a></li><li><a href="/learn/schema/#">타입 언어</a></li><li><a href="/learn/schema/#">객체 타입과 필드</a></li><li><a href="/learn/schema/#">인자</a></li><li><a href="/learn/schema/#">쿼리 타입 &amp; 뮤테이션 타입</a></li><li><a href="/learn/schema/#">스칼라 타입</a></li><li><a href="/learn/schema/#">열거형 타입</a></li><li><a href="/learn/schema/#non-null">리스트와 Non-Null</a></li><li><a href="/learn/schema/#">인터페이스</a></li><li><a href="/learn/schema/#">유니온 타입</a></li><li><a href="/learn/schema/#">입력 타입</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">검증</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">실행</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">스키마 확인</a></li></ul></div><div><h3>모범 사례</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">그래프로 생각하기</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">HTTP를 통한 서빙</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">인증</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">페이지네이션</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">캐싱</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">배우기</a></h5><a href="/learn/">소개</a><a href="/learn/queries/">쿼리 언어</a><a href="/learn/schema/">타입 시스템</a><a href="/learn/execution/">실행</a><a href="/learn/best-practices/">모범 사례</a></div><div><h5><a href="/code">코드</a></h5><a href="/code/#server-libraries">서버</a><a href="/code/#graphql-clients">클라이언트</a><a href="/code/#tools">도구</a></div><div><h5><a href="/community">커뮤니티</a></h5><a href="/community/upcoming-events/">이벤트</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">스택 오버플로우</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">페이스북 그룹</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">트위터</a></div><div><h5>기타</h5><a href="/blog">GraphQL 팀 블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">깃허브</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/learn/Learn-Validation.md" target="_blank" rel="noopener noreferrer">이 페이지 수정 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-99001722-7', 'auto');
ga('send', 'pageview');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.603e3f069b9471780fbd.js"></script></body></html>