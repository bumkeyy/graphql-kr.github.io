<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="google-site-verification" content="wt4jHZa0ru-stSJJrlY5sSJzj9MB0ZA6BzkprNilZdM"/><title>GraphQL 모범 사례 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: API를 위한 쿼리 언어"/><meta property="og:description" content="GraphQL은 API에 있는 데이터에 대한 완벽하고 이해하기 쉬운 설명을 제공하고 클라이언트에게 필요한 것을 정확하게 요청할 수 있는 기능을 제공하며 시간이 지남에 따라 API를 쉽게 진화시키고 강력한 개발자 도구를 지원합니다."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql-kr.github.io"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: API를 위한 쿼리 언어"/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link href="https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css" rel="stylesheet" type="text/css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">배우기</a><a href="/code/">코드</a><a href="/community/">커뮤니티</a><a href="/blog/">블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="문서 검색"/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>GraphQL 모범 사례</h1><div><p>GraphQL 명세는 네트워크, 인증, 페이지네이션 처리와 같은 API가 직면하는 몇 가지 중요한 문제에 대해 의도적으로 다루지 않습니다. GraphQL을 사용할 때 이러한 문제에 대한 해결책이 없다는 것은 아닙니다. 단지 이 문제들은 GraphQL 이 <em>무엇</em> 인지에 대한 것과 직접적인 관련이 없으며 이것은 일반적이기 때문입니다.</p><p>이 섹션에 글은 전적으로 받아 들여서는 안되며, 특정한 경우에는 이 접근방법이 올바르지 않을 수도 있습니다. 이 문서에서는 GraphQL 서비스의 설계 및 배포와 관련된 Facebook에서 개발된 철학을 소개하고, HTTP를 통한 서빙 및 인증과 같은 일반적인 문제를 해결하기 위한 방법을 제안합니다.</p><p>다음에서는 GraphQL 서비스의 가장 일반적인 모범 사례와 좋은 방법에 대해 간략히 설명합니다. 그리고, 이 섹션의 각 문서에서는 이 주제들에 대해 더 자세히 설명합니다.</p><h3><a class="anchor" name="http"></a>HTTP <a class="hash-link" href="#http">#</a></h3><p>GraphQL은 일반적으로 서비스의 모든 기능을 하나의 엔드포인트 HTTP를 통해 제공됩니다. 이는 각각 하나의 리소스를 여러 URL로 노출하는 REST API와는 대조적입니다. GraphQL은 이 리소스 URL들과 함께 사용할 수도 있지만, GraphiQL과 같은 도구를 사용하기가 어려울 수 있습니다.</p><p><a href="/learn/serving-over-http/">Serving over HTTP</a>에서 더 자세히 알아보세요.</p><h3><a class="anchor" name="json-with-gzip"></a>JSON (with GZIP) <a class="hash-link" href="#json-with-gzip">#</a></h3><p>GraphQL 서비스는 일반적으로 JSON으로 응답하지만 GraphQL 명세에서는 <a href="http://facebook.github.io/graphql/#sec-Serialization-Format" target="_blank" rel="nofollow noopener noreferrer">필수는 아닙니다</a>. JSON은 더 좋은 네트워크 성능을 보장하는 API 레이어를 위해서는 이상한 선택처럼 보일 수 있지만 대부분 텍스트이기 때문에 GZIP으로 매우 잘 압축됩니다.</p><p>모든 프로덕션 GraphQL 서비스는 GZIP을 활성화하고 클라이언트가 다음 헤더를 보내는것을 권장합니다.</p><pre class="prism language-undefined">Accept<span class="operator">-</span>Encoding<span class="punctuation">:</span> gzip</pre><p>JSON은 클라이언트 및 API 개발자들에게도 친숙하며, 읽고 디버깅하기 쉽습니다. 실제로 GraphQL 문법은 JSON 문법에 부분적으로 영향을 받았습니다.</p><h3><a class="anchor" name=""></a>버저닝 <a class="hash-link" href="#">#</a></h3><p>GraphQL 서비스가 다른 REST API와 마찬가지로 버전이 변경되는 것을 막을 수는 없지만, GraphQL 스키마의 지속적인 업데이트를 위한 도구를 제공하여 버전 관리를 피하는 것에 대해서 강한 의견을 가지고 있습니다.</p><p>왜 대부분의 API는 버전관리를 해야할까요? API 엔드포인트에서 리턴된 데이터에 대한 변경이 있을 때 <em>모든 변경</em>은 큰 변화를 일으킬 수 있으며, 큰 변경사항에는 새 버전이 필요합니다. API에 새로운 기능을 추가하는데 새로운 버전이 필요한 경우 API를 이해하기 쉽고 유지 보수할 수 있는 버전을 자주 출시하고 업데이트된 버전을 사용하는 것이 좋습니다.</p><p>반대로 GraphQL은 명시적으로 요청된 데이터만 반환하므로 새로운 타입과 필드를 통해 새로운 기능을 추가할 수 있습니다. 이는 항상 변경사항을 피하고 버전없는 API를 제공하는 방법으로 이어집니다.</p><h3><a class="anchor" name="nullability"></a>Nullability <a class="hash-link" href="#nullability">#</a></h3><p><code>null</code> 을 판단하는 대부분의 타입 시스템은, 일반 타입과 해당 타입의 <em>nullable</em> 버전을 제공하며, 명시적으로 선언하지 않는한, 기본 타입은 <code>null</code>을 포함하지 않습니다. 하지만 GraphQL 타입 시스템에서는 모든 필드가 기본적으로 <em>nullable</em> 입니다. 이는 데이터베이스 및 기타 백엔드의 네트워크 서비스에서 많은 일이 발생할 수 있기 때문입니다. 데이터베이스가 다운되거나 비동기 작업이 실패할 수 있으며, 예외가 발생할 수도 있습니다. 단순한 시스템 실패 이외에도 요청 내의 각 필드가 서로 다른 인증 규칙을 가져서, 권한이 세분화될 수 있습니다.</p><p>이러한 이유로 인해 기본적으로 모든 필드를 <em>nullable</em> 로 설정하면 요청이 완전히 실패하지 않고 해당 필드가 <code>null</code> 로 반환될 수 있습니다. 대신, GraphQL은 <a href="/learn/schema/#lists-and-non-null">non-null</a> 타입을 제공하여, 요청시 필드가 절대 <code>null</code> 을 반환하지 않도록 보장할 수 있습니다. 대신에, 만약 오류가 발생하면, 이전 상위 필드가 대신 <code>null</code> 이 됩니다.</p><p>GraphQL 스키마를 설계할 때, 잘못될 수 있는 모든 문제와 실패한 필드에 대해 <code>null</code> 이 적절한 값임을 명심하는 것이 중요합니다. 일반적으로 그렇지만 때로는 그렇지 않는 경우도 있습니다. 이러한 경우, <code>null</code> 이 아님을 보장하는 <code>non-null</code> 타입을 사용하십시오.</p><h3><a class="anchor" name=""></a>페이지네이션 <a class="hash-link" href="#">#</a></h3><p>GraphQL 타입 시스템은 일부 필드가 <a href="/learn/schema/#리스트와-non-null">값의 리스트</a>를 반환하지만 API 설계자는 긴 리스트에 대한 페이지네이션을 제공할 수 있습니다. 페이지네이션을 위한 다양한 API 디자인이 있으며, 각각 장단점이 있습니다.</p><p>일반적으로 긴 리스트을 반환할 수 있는 필드는 <code>first</code>나 <code>after</code> 인수를 사용하여, 목록의 특정 구간을 지정할 수 있습니다. 여기서 <code>after</code> 는 리스트의 각 값에 대한 <code>고유 식별자(unique identifier)</code>입니다.</p><p>기능이 다양한 페이지네이션을 사용하여 궁극적으로 API를 디자인하면 <code>Connections</code> 라는 모범 사례 패턴이 생깁니다. <a href="https://facebook.github.io/relay/" target="_blank" rel="nofollow noopener noreferrer">Relay</a>와 같은 GraphQL의 몇몇 클라이언트 도구는 <code>Connections</code> 패턴을 구현하며, GraphQL API가 이 패턴을 사용할 때 클라이언트 측 페이지네이션을 자동으로 지원합니다.</p><p><a href="/learn/pagination/">페이지네이션</a> 문서에서 자세히 읽어보세요.</p><h3><a class="anchor" name=""></a>서버사이드 배치 &amp; 캐시 <a class="hash-link" href="#">#</a></h3><p>GraphQL은 서버에 깔끔한 코드를 작성할 수 있는 방식으로 설계되었습니다. 모든 타입의 각 필드에는 해당 값을 확인하는데 초점을 맞춘 단일목적(single-purpose) 함수가 있습니다. 하지만 이러한 추가적인 고려없이, 간단한 GraphQL 서비스는 매우 반복적으로 데이터를 데이터베이스에서 로드할 수도 있습니다.</p><p>이은 일반적으로 백엔드의 데이터에 대한 다중 요청이 단기간에 발생할 때, 단일 요청에서 데이터베이스나 마이크로서비스로 전송되는 일괄 처리 기법인 Facebook의 <a href="https://github.com/facebook/dataloader" target="_blank" rel="nofollow noopener noreferrer">DataLoader</a>와 같은 도구를 사용하여 해결할 수 있습니다.</p></div><a class="read-next" href="/learn/thinking-in-graphs"><span class="read-next-continue">계속 읽기 →</span><span class="read-next-title">그래프로 생각하기</span></a></div><div class="nav-docs"><div><h3>배우기</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">쿼리 &amp; 뮤테이션</a><ul><li><a href="/learn/queries/#">필드</a></li><li><a href="/learn/queries/#">인자</a></li><li><a href="/learn/queries/#">별칭</a></li><li><a href="/learn/queries/#">프래그먼트</a></li><li><a href="/learn/queries/#">작업 이름</a></li><li><a href="/learn/queries/#">변수</a></li><li><a href="/learn/queries/#">지시어</a></li><li><a href="/learn/queries/#">뮤테이션</a></li><li><a href="/learn/queries/#">인라인 프래그먼트</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">스키마 &amp; 타입</a><ul><li><a href="/learn/schema/#">타입 시스템</a></li><li><a href="/learn/schema/#">타입 언어</a></li><li><a href="/learn/schema/#">객체 타입과 필드</a></li><li><a href="/learn/schema/#">인자</a></li><li><a href="/learn/schema/#">쿼리 타입 &amp; 뮤테이션 타입</a></li><li><a href="/learn/schema/#">스칼라 타입</a></li><li><a href="/learn/schema/#">열거형 타입</a></li><li><a href="/learn/schema/#non-null">리스트와 Non-Null</a></li><li><a href="/learn/schema/#">인터페이스</a></li><li><a href="/learn/schema/#">유니온 타입</a></li><li><a href="/learn/schema/#">입력 타입</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">검증</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">실행</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">스키마 확인</a></li></ul></div><div><h3>모범 사례</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">그래프로 생각하기</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">HTTP를 통한 서빙</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">인증</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">페이지네이션</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">캐싱</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">배우기</a></h5><a href="/learn/">소개</a><a href="/learn/queries/">쿼리 언어</a><a href="/learn/schema/">타입 시스템</a><a href="/learn/execution/">실행</a><a href="/learn/best-practices/">모범 사례</a></div><div><h5><a href="/code">코드</a></h5><a href="/code/#server-libraries">서버</a><a href="/code/#graphql-clients">클라이언트</a><a href="/code/#tools">도구</a></div><div><h5><a href="/community">커뮤니티</a></h5><a href="/community/upcoming-events/">이벤트</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">스택 오버플로우</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">페이스북 그룹</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">트위터</a></div><div><h5>기타</h5><a href="/blog">GraphQL 팀 블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">깃허브</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/learn/BestPractice-Introduction.md" target="_blank" rel="noopener noreferrer">이 페이지 수정 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-99001722-7', 'auto');
ga('send', 'pageview');
      </script></body></html>