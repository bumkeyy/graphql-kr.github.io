<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>캐싱 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: API를 위한 쿼리 언어"/><meta property="og:description" content="GraphQL은 API에 있는 데이터에 대한 완벽하고 이해하기 쉬운 설명을 제공하고 클라이언트에게 필요한 것을 정확하게 요청할 수 있는 기능을 제공하며 시간이 지남에 따라 API를 쉽게 진화시키고 강력한 개발자 도구를 지원합니다."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql-kr.github.io"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: API를 위한 쿼리 언어"/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">배우기</a><a href="/code/">코드</a><a href="/community/">커뮤니티</a><a href="/blog/">블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="문서 검색"/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>캐싱</h1><div><blockquote><p>객체 식별자를 제공하면 클라이언트가 풍부한 캐시를 구축 할 수 있습니다.</p></blockquote><p>엔드포인트 기반 API에서 클라이언트는 HTTP 캐싱을 사용하여 리소스 재요청을 쉽게 피하고 두 리소스가 동일한 것을 식별할 수 있습니다. 이 API의 URL은 클라이언트가 캐시를 작성하는데 사용할 수있는 <strong>전역 고유 식별자</strong> 입니다. GraphQL에는 주어진 객체에 대해 전역적으로 고유한 식별자를 제공하는 URL과 같은 프리미티브가 없습니다. 그러므로 API가 클라이언트가 사용할 수 있도록 이러한 식별자를 노출하는 것이 가장 좋습니다.</p><h2><a class="anchor" name="globally-unique-ids"></a>Globally Unique IDs <a class="hash-link" href="#globally-unique-ids">#</a></h2><p>가능한 한 가지 패턴은 <code>id</code>와 같은 필드를 전역적으로 고유한 식별자로 사용하는 것입니다. 이 문서 전체에 사용된 예제 스키마는 이 방법을 사용합니다.</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>이것은 클라이언트 개발자에게 넘겨줄 강력한 도구입니다. 리소스 기반 API의 URL이 전역적으로 고유한 키를 제공하는 것과 같은 방식으로 이 시스템의 <code>id</code> 필드는 전역적으로 고유한 키를 제공합니다.</p><p>백엔드가 식별자에 UUID와 같은 것을 사용한다면 이 전역적으로 고유한 ID를 노출하는 것은 매우 간단 할 수 있습니다! 백엔드에 모든 객체에 대한 전역 고유 ID가 없는 경우 GraphQL 계층에서 이를 구성해야 할 수 있습니다. 종종 ID에 타입 이름을 추가하고 이를 식별자로 사용하는 것만큼 간단합니다. 그런 다음 서버는 base64 인코딩을 통해 해당 ID를 불투명하게 만들 수 있습니다.</p><h2><a class="anchor" name="compatibility-with-existing-apis"></a>Compatibility with existing APIs <a class="hash-link" href="#compatibility-with-existing-apis">#</a></h2><p>이러한 목적을 위해 <code>id</code> 필드를 사용하는 것에 대한 한가지 우려는 GraphQL API를 사용하는 클라이언트가 기존 API와 어떻게 작동하는지입니다. 예를 들어 기존 API가 타입별 ID를 허용했지만 GraphQL API가 전역 고유 ID를 사용하는 경우 두 API를 동시에 사용하는 것은 까다로울 수 있습니다.</p><p>이러한 경우 GraphQL API는 이전 API의 ID를 별도의 필드에 표시 할 수 있습니다. 이것은 두 가지 장점을 제공합니다.</p><ul><li>GraphQL 클라이언트는 계속적으로 전역 고유 ID를 얻기위한 일관된 메커니즘에 의존 할 수 있습니다.</li><li>이전 API로 작업해야하는 클라이언트도 객체에서 <code>previousApiId</code> 를 가져와서 사용할 수 있습니다.</li></ul><h2><a class="anchor" name="alternatives"></a>Alternatives <a class="hash-link" href="#alternatives">#</a></h2><p>전역적으로 고유한 ID가 과거에는 강력한 패턴으로 입증되었지만 사용할 수 있는 유일한 패턴이 아니며 모든 상황에 적합한 패턴도 아닙니다. 클라이언트가 필요로 하는 정말로 중요한 기능은 캐싱에 대해 전역으로 고유한 식별자를 파생시킬 수 있는 기능입니다. 서버에서 ID를 파생시키면 클라이언트가 단순화되지만 클라이언트는 식별자도 가져야 할수 있습니다. 이것은 (<code>__typename</code>으로 질의하는) 객체의 타입을 어떤 타입의 고유 식별자와 결합하는 것처럼 간단합니다.</p><p>또한 기존 API를 GraphQL API로 대체하는 경우 GraphQL의 모든 필드가 고유한 것으로 변경된 <code>id</code> 를 <strong>제외</strong> 하고 동일한 경우 혼동을 줄 수 있습니다. 이것이 하나의 전역 고유 필드로서 <code>id</code> 를 사용하지 않기로 결정한 또 다른 이유입니다.</p></div></div><div class="nav-docs"><div><h3>배우기</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">쿼리 &amp; 뮤테이션</a><ul><li><a href="/learn/queries/#">필드</a></li><li><a href="/learn/queries/#">인자</a></li><li><a href="/learn/queries/#">별칭</a></li><li><a href="/learn/queries/#">프래그먼트</a></li><li><a href="/learn/queries/#">작업 이름</a></li><li><a href="/learn/queries/#">변수</a></li><li><a href="/learn/queries/#">지시어</a></li><li><a href="/learn/queries/#">뮤테이션</a></li><li><a href="/learn/queries/#">인라인 프래그먼트</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">스키마 &amp; 타입</a><ul><li><a href="/learn/schema/#">타입 시스템</a></li><li><a href="/learn/schema/#">타입 언어</a></li><li><a href="/learn/schema/#">객체 타입 &amp; 필드</a></li><li><a href="/learn/schema/#">인자</a></li><li><a href="/learn/schema/#">쿼리 &amp; 뮤테이션 타입</a></li><li><a href="/learn/schema/#">스칼라 타입</a></li><li><a href="/learn/schema/#">열거형 타입</a></li><li><a href="/learn/schema/#non-null">리스트 &amp; Non-Null</a></li><li><a href="/learn/schema/#">인터페이스</a></li><li><a href="/learn/schema/#">유니온 타입</a></li><li><a href="/learn/schema/#">입력 타입</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">검증</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">실행</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">검사</a></li></ul></div><div><h3>모범 사례</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">그래프로 생각하기</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">HTTP를 통한 서빙</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">인증</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">페이지네이션</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">캐싱</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">배우기</a></h5><a href="/learn/">소개</a><a href="/learn/queries/">쿼리 언어</a><a href="/learn/schema/">타입 시스템</a><a href="/learn/execution/">실행</a><a href="/learn/best-practices/">모범 사례</a></div><div><h5><a href="/code">코드</a></h5><a href="/code/#server-libraries">서버</a><a href="/code/#graphql-clients">클라이언트</a><a href="/code/#tools">도구</a></div><div><h5><a href="/community">커뮤니티</a></h5><a href="/community/upcoming-events/">이벤트</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">스택 오버플로우</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">페이스북 그룹</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">트위터</a></div><div><h5>기타</h5><a href="/blog">GraphQL 팀 블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">깃허브</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/learn/BestPractice-Caching.md" target="_blank" rel="noopener noreferrer">이 페이지 수정 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.6c57acc0fb93721aad00.js"></script></body></html>