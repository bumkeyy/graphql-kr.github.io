<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="google-site-verification" content="wt4jHZa0ru-stSJJrlY5sSJzj9MB0ZA6BzkprNilZdM"/><title>실행 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: API를 위한 쿼리 언어"/><meta property="og:description" content="GraphQL은 API에 있는 데이터에 대한 완벽하고 이해하기 쉬운 설명을 제공하고 클라이언트에게 필요한 것을 정확하게 요청할 수 있는 기능을 제공하며 시간이 지남에 따라 API를 쉽게 진화시키고 강력한 개발자 도구를 지원합니다."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql-kr.github.io"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: API를 위한 쿼리 언어"/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">배우기</a><a href="/code/">코드</a><a href="/community/">커뮤니티</a><a href="/blog/">블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="문서 검색"/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>실행</h1><div><p>유효성검사를 한 후, GraphQL 쿼리는 GraphQL 서버에서 실행되어, 요청된 쿼리와 똑같은 형태의 결과를 반환합니다. 일반적으로 JSON 형태입니다.</p><p>GraphQL은 타입시스템 없이 쿼리를 실행할 수 없습니다. 예제를 통해 쿼리 실행에 대하여 설명하겠습니다. 아래는 이전 예제와 동일한 일부 타입 시스템입니다.</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Query <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">human</span><span class="argDefs"><span class="punctuation">(</span><span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="operator">!</span><span class="punctuation">)</span></span><span class="punctuation">:</span> <span class="type-name">Human</span>
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">type</span> Human <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span>
  <span class="attr-name">starships</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Starship</span><span class="punctuation">]</span>
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">enum</span> Episode <span class="fields"><span class="punctuation">{</span>
  NEWHOPE
  EMPIRE
  JEDI
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">type</span> Starship <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span>
<span class="punctuation">}</span></span></span></pre><p>쿼리가 실행될 때 어떤 일이 발생하는지 예제로 살펴 보겠습니다.</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>GraphQL 쿼리의 각 필드는 다음 타입을 반환하는 타입의 함수로 생각할 수 있습니다. 사실 이것이 GraphQL의 작동방식입니다. 타입의 각 필드는 GraphQL 서버개발자가 만든 <code>resolver</code> 함수에 의해 실행됩니다. 필드가 실행되면 해당 <code>resolver</code> 가 호출되어 다음 값을 생성합니다.</p><p>필드가 문자열이나 숫자 같은 스칼라 값을 반환하면 실행이 완료됩니다. 하지만 필드가 객체를 반환하면 쿼리는 해당 객체에 적용되는 다른 필드들을 포함하게됩니다. 이는 스칼라 값에 도달할 때까지 반복됩니다. GraphQL 쿼리의 끝은 항상 스칼라 값입니다.</p><h2><a class="anchor" name="resolvers"></a>루트 필드 &amp; resolvers <a class="hash-link" href="#resolvers">#</a></h2><p>모든 GraphQL 서버의 최상위 레벨은 GraphQL API에서 사용 가능한 모든 진입점을 나타내는 타입으로, <code>Root</code> 타입 또는 <code>Query</code> 타입이라고도 합니다.</p><p>아래 예제에서 <code>Query</code> 타입은 인자 <code>id</code> 를 받아 <code>human</code> 필드를 반환합니다. 이 필드의 <code>resolver</code> 함수는 데이터베이스에 접근한 다음 <code>Human</code> 객체를 생성하고 반환합니다.</p><pre class="prism language-js">Query<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">human</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> context<span class="punctuation">.</span>db<span class="punctuation">.</span><span class="function">loadHumanByID</span><span class="punctuation">(</span>args<span class="punctuation">.</span>id<span class="punctuation">)</span><span class="punctuation">.</span><span class="function">then</span><span class="punctuation">(</span>
      userData <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">new</span> <span class="class-name">Human</span><span class="punctuation">(</span>userData<span class="punctuation">)</span>
    <span class="punctuation">)</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>이 예제는 자바스크립트로 작성되었지만 GraphQL 서버는 <a href="/code/">다양한 언어</a>로 만들 수 있습니다. <code>resolver</code> 함수는 네 개의 인수를 받습니다.</p><ul><li><code>obj</code>: 대부분 사용되지 않는 루트 <code>Query</code> 타입의 이전 객체.</li><li><code>args</code>: GraphQL 쿼리의 필드에 제공된 인수.</li><li><code>context</code>: 모든 <code>resolver</code> 함수에 전달되며, 현재 로그인한 사용자, 데이터베이스 액세스와 같은 중요한 문맥 정보를 보유하는 값.</li><li><code>info</code>: 현재 쿼리, 스키마 정보와 관련된 필드별 정보를 보유하는 값. 자세한 내용은 <a href="/graphql-js/type/#graphqlobjecttype">type GraphQLResolveInfo</a> 참조.</li></ul><h2><a class="anchor" name="resolvers-1"></a>비동기 resolvers <a class="hash-link" href="#resolvers-1">#</a></h2><p>아래 <code>resolver</code> 함수에서 어떤 일이 일어나는지 자세히 살펴보겠습니다.</p><pre class="prism language-js"><span class="function">human</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> context<span class="punctuation">.</span>db<span class="punctuation">.</span><span class="function">loadHumanByID</span><span class="punctuation">(</span>args<span class="punctuation">.</span>id<span class="punctuation">)</span><span class="punctuation">.</span><span class="function">then</span><span class="punctuation">(</span>
    userData <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">new</span> <span class="class-name">Human</span><span class="punctuation">(</span>userData<span class="punctuation">)</span>
  <span class="punctuation">)</span>
<span class="punctuation">}</span></pre><p><code>context</code> 는 GraphQL 쿼리 인자로 제공된 <code>id</code> 로 사용자 데이터를 로드하는데 사용되는 데이터베이스 액세스를 위해 사용됩니다. 데이터베이스 로딩은 비동기 작업이기 때문에 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="nofollow noopener noreferrer">Promise</a>를 반환합니다. JavaScript에서는 <code>Promise</code> 를 사용하여 비동기 값을 처리하지만, 동일한 개념이 <code>Futures</code> , <code>Tasks</code> , <code>Deferred</code> 등 여러가지 언어로 존재합니다. 데이터베이스가 반환되면 새로운 <code>Human</code> 객체를 생성하고 반환할 수 있습니다.</p><p><code>resolver</code> 함수는 <code>Promise</code> 를 인식해야하지만 GraphQL 쿼리는 <code>Promise</code> 를 인식할 필요가 없습니다. <code>human</code> 필드는 <code>name</code> 을 요청할 수 있는 무언가를 반환할 것입니다. 실행할 때, GraphQL은 <code>Promises</code>, <code>Futures</code>, <code>Tasks</code> 가 완료될 때까지 기다렸다가 효율적으로 동시에 처리합니다.</p><h2><a class="anchor" name="resolvers-2"></a>기본 resolvers <a class="hash-link" href="#resolvers-2">#</a></h2><p>이제 <code>Human</code> 객체를 사용할 수 있게 되었으므로, GraphQL 은 요청된 필드를 사용할 수 있습니다.</p><pre class="prism language-js">Human<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">name</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> obj<span class="punctuation">.</span>name
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>GraphQL 서버는 타입 시스템을 통해 작동하며, 이는 다음에 어떤 작업을 수행해야할지 결정해줍니다. <code>human</code> 필드가 무언가를 반환하기 전에, GraphQL은 타입 시스템 덕분에 <code>human</code> 필드가 <code>Human</code> 을 반환할 것을 이미 알고 있습니다.</p><p>이 경우 <code>name</code> 을 <code>resolve</code> 하는 것은 매우 간단합니다. <code>name resolver</code> 함수가 호출되며, <code>obj</code> 인자는 이전 필드에서 반환된 <code>new Human</code> 객체입니다. <code>Human</code> 객체는 바로 반환할 수 있는 <code>name</code> 속성을 가질 것을 알 수 있습니다.</p><p>사실, 많은 GraphQL 라이브러리는 <code>resolver</code> 를 생략할 수 있게 해주며, <code>resolver</code> 가 필드에 제공되지 않으면 같은 이름의 속성을 읽고 반환한다고 가정합니다.</p><h2><a class="anchor" name=""></a>스칼라 강제 <a class="hash-link" href="#">#</a></h2><p><code>name</code> 필드가 <code>resolve</code> 되는 동안 <code>appearIn</code> 과 <code>starships</code> 필드는 동시에 <code>resolve</code> 될 수 있습니다. <code>appearIn</code> 필드는 간단한 <code>resolver</code> 를 가질 수도 있지만, 좀 더 자세히 살펴보도록 하겠습니다.</p><pre class="prism language-js">Human<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">appearsIn</span><span class="punctuation">(</span>obj<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> obj<span class="punctuation">.</span>appearsIn <span spellcheck="true" class="comment">// returns [ 4, 5, 6 ]</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>타입 시스템이 <code>appearIn</code> 이 열거형 값을 반환한다고 알려주지만, 이 함수는 숫자를 반환합니다. 실제로 결과를 살펴보면 적절한 열거형 값이 반환되는 것을 볼 수 있습니다. 어떻게된 일일까요?</p><p>이것은 스칼라 강제의 예시입니다. 타입 시스템은 어떤 값이 반환될지 알고 있어서 <code>resolver</code> 함수에 의해 리턴된 값을 API 규약을 유지할 수 있는 형태로 변환할 것입니다. 이 경우 내부적으로 <code>4</code>,<code>5</code>,<code>6</code> 과 같은 숫자를 사용하는 열거형이 서버에 정의되어 있을 수 있지만, GraphQL 타입 시스템에서는 이를 열거형 값으로 나타냅니다.</p><h2><a class="anchor" name="resolvers-3"></a>리스트 resolvers <a class="hash-link" href="#resolvers-3">#</a></h2><p>필드가 위의 <code>appearIn</code> 필드 리스트를 반환할 때 어떤 일이 벌어지는지 살펴 보았습니다. 이것은 열거형 값의 <em>리스트</em> 를 반환했으며, 타입 시스템에서 예상한대로 리스트의 각 항목이 적절한 열거형 값으로 강제 변환되었습니다. <code>starships</code> 필드가 <code>resolve</code> 되면 어떻게 될까요?</p><pre class="prism language-js">Human<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">starships</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> obj<span class="punctuation">.</span>starshipIDs<span class="punctuation">.</span><span class="function">map</span><span class="punctuation">(</span>
      id <span class="operator">=</span><span class="operator">&gt;</span> context<span class="punctuation">.</span>db<span class="punctuation">.</span><span class="function">loadStarshipByID</span><span class="punctuation">(</span>id<span class="punctuation">)</span><span class="punctuation">.</span><span class="function">then</span><span class="punctuation">(</span>
        shipData <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">new</span> <span class="class-name">Starship</span><span class="punctuation">(</span>shipData<span class="punctuation">)</span>
      <span class="punctuation">)</span>
    <span class="punctuation">)</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>이 필드의 <code>resolver</code> 는 <code>Promise</code> 를 반환하는 것이 아니라 <code>Promise</code>의 <em>리스트</em> 를 반환합니다. <code>Human</code> 객체는 이것이 처리한 <code>Starships</code> 의 <code>id</code> 리스트를 가지고 있지만, 실제 <code>Starship</code> 객체를 얻으려면 모든 <code>id</code> 를 로드해야 합니다.</p><p>GraphQL 은 모든 <code>Promise</code> 들을 기다릴 것이고, 객체 리스트로 남을 때, 동시에 이 아이템들의 각각에 <code>name</code> 필드를 다시 로드할 것입니다.</p><h2><a class="anchor" name=""></a>결과 생성하기 <a class="hash-link" href="#">#</a></h2><p>각 필드가 <code>resolve</code> 될 때, 결과 값은 필드 이름(또는 별칭)을 <code>key</code> 로 사용하고 <code>resolve</code> 된 값을 <code>value</code> 로 사용하여 <code>key</code>-<code>value</code> 맵에 들어갑니다. 이 방법은 쿼리의 맨 하단 끝 필드에서부터 루트 쿼리 타입의 처음 필드까지 반복됩니다. 최종적으로 기존 쿼리를 미러링하는 구조를 만들어서 요청한 클라이언트에 (일반적으로 JSON) 보낼 수 있습니다.</p><p>마지막으로 기존 쿼리를 살펴보고 이러한 모든 <code>resolver</code> 함수가 결과를 어떻게 생성하는지 살펴보겠습니다.</p><div id="r102"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div></div><a class="read-next" href="/learn/introspection"><span class="read-next-continue">계속 읽기 →</span><span class="read-next-title">검사</span></a></div><div class="nav-docs"><div><h3>배우기</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">쿼리 &amp; 뮤테이션</a><ul><li><a href="/learn/queries/#">필드</a></li><li><a href="/learn/queries/#">인자</a></li><li><a href="/learn/queries/#">별칭</a></li><li><a href="/learn/queries/#">프래그먼트</a></li><li><a href="/learn/queries/#">작업 이름</a></li><li><a href="/learn/queries/#">변수</a></li><li><a href="/learn/queries/#">지시어</a></li><li><a href="/learn/queries/#">뮤테이션</a></li><li><a href="/learn/queries/#">인라인 프래그먼트</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">스키마 &amp; 타입</a><ul><li><a href="/learn/schema/#">타입 시스템</a></li><li><a href="/learn/schema/#">타입 언어</a></li><li><a href="/learn/schema/#">객체 타입과 필드</a></li><li><a href="/learn/schema/#">인자</a></li><li><a href="/learn/schema/#">쿼리 타입 &amp; 뮤테이션 타입</a></li><li><a href="/learn/schema/#">스칼라 타입</a></li><li><a href="/learn/schema/#">열거형 타입</a></li><li><a href="/learn/schema/#non-null">리스트와 Non-Null</a></li><li><a href="/learn/schema/#">인터페이스</a></li><li><a href="/learn/schema/#">유니온 타입</a></li><li><a href="/learn/schema/#">입력 타입</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">검증</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">실행</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">검사</a></li></ul></div><div><h3>모범 사례</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">그래프로 생각하기</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">HTTP를 통한 서빙</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">인증</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">페이지네이션</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">캐싱</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">배우기</a></h5><a href="/learn/">소개</a><a href="/learn/queries/">쿼리 언어</a><a href="/learn/schema/">타입 시스템</a><a href="/learn/execution/">실행</a><a href="/learn/best-practices/">모범 사례</a></div><div><h5><a href="/code">코드</a></h5><a href="/code/#server-libraries">서버</a><a href="/code/#graphql-clients">클라이언트</a><a href="/code/#tools">도구</a></div><div><h5><a href="/community">커뮤니티</a></h5><a href="/community/upcoming-events/">이벤트</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">스택 오버플로우</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">페이스북 그룹</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">트위터</a></div><div><h5>기타</h5><a href="/blog">GraphQL 팀 블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">깃허브</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/learn/Learn-Execution.md" target="_blank" rel="noopener noreferrer">이 페이지 수정 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.ca8371bf2f4a0147d4f6.js"></script></body></html>