<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>실행 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: A query language for APIs."/><meta property="og:description" content="GraphQL provides a complete description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.org/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: A query language for APIs."/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">배우기</a><a href="/code/">코드</a><a href="/community/">커뮤니티</a><a href="/blog/">블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="Search docs..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>실행</h1><div><p>유효성을 검사 한 후 GraphQL 쿼리는 GraphQL 서버에 의해 실행되어 요청된 쿼리의 형태를 일반적인 JSON 형태의 결과를 반환합니다.</p><p>GraphQL은 타입 시스템없이는 쿼리를 실행할 수 없습니다. 예제를 통해 쿼리 실행에 대하여 설명하겠습니다. 이전 예제에서 사용된 것과 동일한 타입 시스템의 일부입니다.</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Query <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">human</span><span class="argDefs"><span class="punctuation">(</span><span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="operator">!</span><span class="punctuation">)</span></span><span class="punctuation">:</span> <span class="type-name">Human</span>
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">type</span> Human <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span>
  <span class="attr-name">starships</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Starship</span><span class="punctuation">]</span>
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">enum</span> Episode <span class="fields"><span class="punctuation">{</span>
  NEWHOPE
  EMPIRE
  JEDI
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">type</span> Starship <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span>
<span class="punctuation">}</span></span></span></pre><p>쿼리가 실행될 때 어떤 일이 발생하는지 설명하기 위해 예제를 사용하여 살펴 보겠습니다.</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>GraphQL 쿼리의 각 필드는 다음 타입을 반환하는 이전 타입의 함수 또는 메소드로 생각할 수 있습니다. 사실 이것은 GraphQL의 작동 방식입니다. 각 타입의 각 필드는 GraphQL 서버 개발자가 만든 <em>resolver</em> 함수에 의해 지원됩니다. 필드가 실행되면 해당 <em>resolver</em> 가 호출되어 다음 값을 생성합니다.</p><p>필드가 문자열이나 숫자와 같은 스칼라 값을 생성하면 실행이 완료됩니다. 그러나 필드가 객체를 생성하면 쿼리는 해당 객체에 적용되는 다른 필드 선택 항목을 포함하게됩니다. 이 스칼라 값에 도달할 때까지 반복됩니다. GraphQL 쿼리는 항상 스칼라 값으로 끝납니다.</p><h2><a class="anchor" name="root-fields-resolvers"></a>Root fields &amp; resolvers <a class="hash-link" href="#root-fields-resolvers">#</a></h2><p>모든 GraphQL 서버의 최상위 레벨은 GraphQL API에 가능한 모든 진입점을 나타내는 타입으로, <em>Root</em> 타입 또는 <em>Query</em> 타입이라고도 합니다.</p><p>이 예제에서 Query 타입은 인자 <code>id</code> 를 받아들이는 <code>human</code> 필드를 제공합니다. 이 필드의 <em>resolver</em> 함수는 데이터베이스에 액세스 한 다음 <code>Human</code> 객체를 생성하고 반환합니다.</p><pre class="prism language-js">Query<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">human</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> context<span class="punctuation">.</span>db<span class="punctuation">.</span><span class="function">loadHumanByID</span><span class="punctuation">(</span>args<span class="punctuation">.</span>id<span class="punctuation">)</span><span class="punctuation">.</span><span class="function">then</span><span class="punctuation">(</span>
      userData <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">new</span> <span class="class-name">Human</span><span class="punctuation">(</span>userData<span class="punctuation">)</span>
    <span class="punctuation">)</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>이 예제는 자바스크립트로 작성되었지만 GraphQL 서버는 <a href="/code/">다양한 언어</a>로 만들 수 있습니다. <em>resolver</em> 함수는 세 개의 인수를 받습니다.</p><ul><li><code>obj</code>: 루트 쿼리 타입의 필드에 대해 종종 사용되지 않는 이전 객체.</li><li><code>args</code>: GraphQL 쿼리의 필드에 제공된 인수입니다.</li><li><code>context</code>: 모든 <em>resolver</em> 함수에 제공되고 현재 로그인한 사용자 또는 데이터베이스에 대한 액세스와 같은 중요한 문맥 정보를 보유하는 값.</li></ul><h2><a class="anchor" name="asynchronous-resolvers"></a>Asynchronous resolvers <a class="hash-link" href="#asynchronous-resolvers">#</a></h2><p>이 <em>resolver</em> 함수에서 어떤 일이 일어나는지 자세히 살펴보겠습니다.</p><pre class="prism language-js"><span class="function">human</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> context<span class="punctuation">.</span>db<span class="punctuation">.</span><span class="function">loadHumanByID</span><span class="punctuation">(</span>args<span class="punctuation">.</span>id<span class="punctuation">)</span><span class="punctuation">.</span><span class="function">then</span><span class="punctuation">(</span>
    userData <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">new</span> <span class="class-name">Human</span><span class="punctuation">(</span>userData<span class="punctuation">)</span>
  <span class="punctuation">)</span>
<span class="punctuation">}</span></pre><p><code>context</code> 는 GraphQL 쿼리에서 인자로 제공된 <code>id</code> 에 의해 사용자의 데이터를 로드하는데 사용되는 데이터베이스에 대한 액세스를 위해 사용됩니다. 데이터베이스에서 로딩은 비동기 작업이기 때문에 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="nofollow noopener noreferrer">Promise</a>를 반환합니다. JavaScript에서는 <code>Promise</code> 를 사용하여 비동기 값을 처리하지만 동일한 개념이 <em>Futures</em> , <em>Tasks</em> , <em>Deferred</em> 등 여러가지 언어로 존재합니다. 데이터베이스가 반환되면 새로운 <code>Human</code> 객체를 생성하고 반환할 수 있습니다.</p><p><em>resolver</em> 함수는 <code>Promise</code> 를 인식해야하지만 GraphQL 쿼리는 Promise를 인식 할 필요가 없습니다. <code>human</code> 필드는 <code>name</code> 을 요청할 수 있는 무언가를 반환 할 것입니다. 실행 중에 GraphQL은 <code>Promises</code>, <code>Futures</code>, <code>Tasks</code> 가 완료되기 전에 완료될 때까지 기다렸다가 효율적으로 동시에 처리합니다.</p><h2><a class="anchor" name="trivial-resolvers"></a>Trivial resolvers <a class="hash-link" href="#trivial-resolvers">#</a></h2><p>이제 <code>Human</code> 객체를 사용할 수 있게 되었으므로 GraphQL 실행은 요청된 필드를 계속 사용할 수 있습니다.</p><pre class="prism language-js">Human<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">name</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> obj<span class="punctuation">.</span>name
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>GraphQL 서버는 다음에 수행할 작업을 결정하는 타입 시스템에 의해 작동됩니다. <code>human</code> 필드가 무언가를 반환하기 전에, GraphQL은 타입 시스템이 <code>human</code> 필드가 <code>Human</code> 을 반환 할 것이라고 알려주기 때문에 다음 단계는 <code>Human</code> 타입의 필드를 반환할 것이라는 것을 알고 있습니다.</p><p>이 경우 <code>name</code> 을 해석하는 것은 매우 간단합니다. <code>name</code> <em>resolver</em> 함수가 호출되고 <code>obj</code> 인수는 이전 필드에서 반환 된 <code>new Human</code> 객체입니다. <code>Human</code> 객체는 직접 읽고 반환 할 수 있는 <code>name</code> 속성을 가질 것을 알 수 있습니다.</p><p>사실, 많은 GraphQL 라이브러리는 <em>resolver</em> 를 생략할 수 있게 해주며, <em>resolver</em> 가 필드에 제공되지 않으면 같은 이름의 속성을 읽고 반환해야 한다고 가정됩니다.</p><h2><a class="anchor" name="scalar-coercion"></a>Scalar coercion <a class="hash-link" href="#scalar-coercion">#</a></h2><p><code>name</code> 필드가 <em>resolve</em> 되는 동안 <code>appearIn</code> 과 <code>starships</code> 필드는 동시에 <em>resolve</em> 될 수 있습니다. <code>appearIn</code> 필드는 간단한 <em>resolver</em> 를 가질 수도 있지만 좀 더 자세히 살펴보도록 하겠습니다.</p><pre class="prism language-js">Human<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">appearsIn</span><span class="punctuation">(</span>obj<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> obj<span class="punctuation">.</span>appearsIn <span spellcheck="true" class="comment">// returns [ 4, 5, 6 ]</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>타입 시스템이 <code>appearIn</code> 이 알고있는 Enum 값을 반환한다고 알려주지만 이 함수는 숫자를 반환합니다! 실제로 결과를 살펴보면 적절한 Enum 값이 반환되는 것을 볼 수 있습니다. 어떻게된 일일까요?</p><p>이것은 스칼라 강제의 예입니다. 타입 시스템은 어떤 값이 올지 알고 있어서 <em>resolver</em> 함수에 의해 리턴된 값을 API 규약을 유지할 수 있는 형태로 변환 할 것입니다. 이 경우 내부적으로 <code>4</code>,<code>5</code>,<code>6</code> 과 같은 숫자를 사용하는 Enum 이 서버에 정의되어 있을 수 있지만 GraphQL 타입 시스템에서는 이를 Enum 값으로 나타냅니다.</p><h2><a class="anchor" name="list-resolvers"></a>List resolvers <a class="hash-link" href="#list-resolvers">#</a></h2><p>필드가 위의 <code>appearIn</code> 필드 리스트를 반환 할 때 어떤 일이 벌어지는지 살펴 보았습니다. 이것은 열거형 값의 <em>list</em> 를 반환했으며, 이 때문에 타입 시스템에서 예상한대로 리스트의 각 항목이 적절한 열거형 값으로 강제 변환되었습니다. <code>starships</code> 필드가 <em>resolve</em> 되면 어떻게 될까요?</p><pre class="prism language-js">Human<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">starships</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> obj<span class="punctuation">.</span>starshipIDs<span class="punctuation">.</span><span class="function">map</span><span class="punctuation">(</span>
      id <span class="operator">=</span><span class="operator">&gt;</span> context<span class="punctuation">.</span>db<span class="punctuation">.</span><span class="function">loadStarshipByID</span><span class="punctuation">(</span>id<span class="punctuation">)</span><span class="punctuation">.</span><span class="function">then</span><span class="punctuation">(</span>
        shipData <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">new</span> <span class="class-name">Starship</span><span class="punctuation">(</span>shipData<span class="punctuation">)</span>
      <span class="punctuation">)</span>
    <span class="punctuation">)</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>이 필드의 <em>resolver</em> 는 <code>Promise</code> 를 반환하는 것이 아니라 <code>Promise</code>의 <em>list</em> 을 반환합니다. <code>Human</code> 객체는 이것이 처리한 <code>Starships</code> 의 id list 를 가지고 있지만, 실제 <code>Starship</code> 객체를 얻으려면 모든 id를 로드해야 합니다.</p><p>GraphQL 은 계속하기 전에 이 모든 <code>Promise</code> 들을 기다릴 것이고, 객체의 리스트와 함께 남겨질 때 동시에 이 아이템들의 각각에 <code>name</code> 필드를 다시 로드 할 것입니다.</p><h2><a class="anchor" name="producing-the-result"></a>Producing the result <a class="hash-link" href="#producing-the-result">#</a></h2><p>각 필드가 <em>resolve</em> 될 때 결과 값은 필드 이름(또는 별칭)을 키로 사용하고 <em>resolve</em>된 값을 값으로 사용하여 <code>key</code>-<code>value</code> 맵에 들어갑니다. 이 방법은 쿼리의 맨 하단 끝 필드에서부터 루트 쿼리 타입의 초기 필드까지 반복됩니다. 최종적으로 기존 쿼리를 미러링하는 구조를 만들어서 요청한 클라이언트에 (일반적으로 JSON으로) 보낼 수 있습니다.</p><p>원래의 쿼리를 마지막으로 살펴보고 이러한 모든 <em>revoler</em> 함수가 결과를 어떻게 생성하는지 살펴 보겠습니다.</p><div id="r102"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div></div><a class="read-next" href="/learn/introspection"><span class="read-next-continue">계속 읽기 →</span><span class="read-next-title">복원</span></a></div><div class="nav-docs"><div><h3>배우기</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">소개</a></li></ul></div><div><h3>Learn</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/queries/">쿼리 &amp; 뮤테이션</a><ul><li><a href="/learn/queries/#fields">Fields</a></li><li><a href="/learn/queries/#arguments">Arguments</a></li><li><a href="/learn/queries/#aliases">Aliases</a></li><li><a href="/learn/queries/#fragments">Fragments</a></li><li><a href="/learn/queries/#operation-name">Operation Name</a></li><li><a href="/learn/queries/#variables">Variables</a></li><li><a href="/learn/queries/#directives">Directives</a></li><li><a href="/learn/queries/#mutations">Mutations</a></li><li><a href="/learn/queries/#inline-fragments">Inline Fragments</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">스키마 &amp; 타입</a><ul><li><a href="/learn/schema/#type-system">Type System</a></li><li><a href="/learn/schema/#type-language">Type Language</a></li><li><a href="/learn/schema/#object-types-and-fields">Object Types and Fields</a></li><li><a href="/learn/schema/#arguments">Arguments</a></li><li><a href="/learn/schema/#the-query-and-mutation-types">The Query and Mutation Types</a></li><li><a href="/learn/schema/#scalar-types">Scalar Types</a></li><li><a href="/learn/schema/#enumeration-types">Enumeration Types</a></li><li><a href="/learn/schema/#lists-and-non-null">Lists and Non-Null</a></li><li><a href="/learn/schema/#interfaces">Interfaces</a></li><li><a href="/learn/schema/#union-types">Union Types</a></li><li><a href="/learn/schema/#input-types">Input Types</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">검사</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">실행</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">복원</a></li></ul></div><div><h3>Best Practices</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">그래프로 생각하기</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">HTTP를 통한 서빙</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">인증</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">Pagination</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">Caching</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">배우기</a></h5><a href="/learn/">소개</a><a href="/learn/queries/">쿼리 언어</a><a href="/learn/schema/">타입 시스템</a><a href="/learn/execution/">실행</a><a href="/learn/best-practices/">모범 사례</a></div><div><h5><a href="/code">코드</a></h5><a href="/code/#server-libraries">서버</a><a href="/code/#graphql-clients">클라이언트</a><a href="/code/#tools">도구</a></div><div><h5><a href="/community">커뮤니티</a></h5><a href="/community/upcoming-events/">이벤트</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">스택 오버플로우</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">페이스북 그룹</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">트위터</a></div><div><h5>기타</h5><a href="/blog">GraphQL 팀 블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">깃허브</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/learn/Learn-Execution.md" target="_blank" rel="noopener noreferrer">이 페이지 수정 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.0946a2481783a2043d32.js"></script></body></html>